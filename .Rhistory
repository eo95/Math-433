h <- 1
n <- 2
(1.18)^(0.5)
r <- c(0,0.2)
delta <- c(0,0)
S_m <- (22,27,17,35,30,25,20)
S_m <- c(22,27,17,35,30,25,20)
C_m <- vector("numeric",2^(n+1)-1)
D_m <- vector("numeric",2^(n+1)-1)
B_m <- vector("numeric",2^(n+1)-1)
a <- 2^(n)
b <- 2^(n+1)-1
S_T <- S_m[a:b]
C_m[a:b] <- payoff(S_T,P$K)
K <- 20
eur <- T
C_m[a:b] <- payoff(S_T,K)
payoff <- call_payoff
payoff <- function(S,K){
output <- ifelse(S>K,S-K,0)
return(output)
}
C_m[a:b] <- payoff(S_T,K)
solution <- solve_binomial_pricing_nonconstant(S_m,C_m,D_m,B_m,r,h,n eur,payoff=payoff,K,delta)
solution <- solve_binomial_pricing_nonconstant(S_m,C_m,D_m,B_m,r,h,n, eur,payoff=payoff,K,delta)
solve_binomial_pricing_nonconstant <- function(S_m,C_m,D_m,B_m,r,h,n,eur,payoff,K,delta){
# Solves the values of C, D, and B for each node of the binomial tree.
# Requires the matrix S_m, C_m, D_m, and B_m. As well as r, h, n, delta.
# If not a European option, requires the payoff function, K.
# Output is a list of numeric matrices: S_m, C_m, D_m, and B_m
for(i in seq(n,1,-1)){
for(j in seq(1,2^(i-1))){
k <- 2^(i-1) + j -1
values   <- one_step_claim(S_m[k],S_m[2*k],S_m[2*k + 1],C_m[2*k],C_m[2*k+1],r[i],h,delta[i])
C_m[k] <- values[1]
D_m[k] <- values[2]
B_m[k] <- values[3]
}
if(!eur){
a <- 2^i
b <- b
C_1 <- C_m[a:b]
S_i <- S_m[a:b]
C_2 <- payoff(S_i,K)
C_i <- ifelse(C_1>C_2,C_1,C_2)
C_m[a:b] <- C_i
}
}
return(list(S_m,C_m,D_m,B_m))
}
solution <- solve_binomial_pricing_nonconstant(S_m,C_m,D_m,B_m,r,h,n, eur,payoff=payoff,K,delta)
one_step_claim <- function(S,Su,Sd,Cu,Cd,r,h,delta) {
# The function solves for C, D, B as a one time step binomial tree
# Outputs a numeric vector of C, D, B
u <- Su/S
d <- Sd/S
D <- exp(-delta*h)*(Cu-Cd)/(Su-Sd)
B <- exp(-r*h)*(u*Cd-d*Cu)/(u-d)
C <- B + D*S
return(c(C,D,B))
}
solution <- solve_binomial_pricing_nonconstant(S_m,C_m,D_m,B_m,r,h,n, eur,payoff=payoff,K,delta)
solution[[2]]
one_step_claim(27,35,30,15,10,0.2,1,0)
5/1.2
-20/1.2
one_step_claim_discrete <- function(S,Su,Sd,Cu,Cd,r,h,D) {
# The function solves for C, A, B as a one time step binomial tree
# with discrete dividends
# D is the value of the dividend at time t + h
# Outputs a numeric vector of C, A, B
u <- Su/S
d <- Sd/S
A <- (Cu-Cd)/(Su-Sd)
B <- exp(-r*h)*(Su*Cd-Sd*Cu)/(Su-Sd) - A*D*exp(-r*h)
C <- B + A*S
return(c(C,A,B))
}
one_step_claim_discrete(27,35,30,15,10,0.2,1,0)
3.5
0.7
(3.5/0.6)%%1
(3.5/0.6)%1
mod(3.5/6,1)
floor(3.5/6)
floor(3.5/0.6)
rep(0,3)
generate_D <- function(vec,n,h,r){
# Creates a vector of D's in the form needed for one_step_claim_discrete
# from vector in (time, dividend, time, dividend,...) form
# assuming the times are in increasing order
len <- length(vec)
output <- c()
for (i in seq(1,len,2)){
t <- vec[i]
j <- floor(t/h)
output <- append(output,rep(0,j))
t <- t - h*(j+1)
D <- vec[i+1]
D <- D*e^(r*t)
output <- append(output, D)
}
i <- length(output)
i <- n - i
output <- append(output, rep(0,i))
return(output)
}
generate_D <- function(vec,n,h,r){
# Creates a vector of D's in the form needed for one_step_claim_discrete
# from vector in (time, dividend, time, dividend,...) form
# assuming the times are in increasing order
len <- length(vec)
output <- c()
for (i in seq(1,len,2)){
t <- vec[i]
j <- floor(t/h)
output <- append(output,rep(0,j))
t <- t - h*(j+1)
D <- vec[i+1]
D <- D*e^(r*t)
output <- append(output, D)
}
i <- length(output)
if (i > n){
output <- output[1:n]
} else{
i <- n - i
output <- append(output, rep(0,i))
}
return(output)
}
vec <- c(0.5,2,0.7,4,0.9,4)
vec <- c(0.5,2,0.7,4,0.9,4,1.2,6)
n <- 4
h <- 0.25
r <- 0
generate_D(vec,n,h,r)
generate_D <- function(vec,n,h,r){
# Creates a vector of D's in the form needed for one_step_claim_discrete
# from vector in (time, dividend, time, dividend,...) form
# assuming the times are in increasing order
len <- length(vec)
output <- c()
for (i in seq(1,len,2)){
t <- vec[i]
j <- floor(t/h)
output <- append(output,rep(0,j))
t <- t - h*(j+1)
D <- vec[i+1]
D <- D*exp(r*t)
output <- append(output, D)
}
i <- length(output)
if (i > n){
output <- output[1:n]
} else{
i <- n - i
output <- append(output, rep(0,i))
}
return(output)
}
generate_D(vec,n,h,r)
seq(1,4,2)
length(vec)
seq(1,8,2)
i <- 1
t <- vec[1]
t
j <- floor(t/h)
j
ceil(2)
ceiling(2)
ceiling(0.7)
generate_D <- function(vec,n,h,r){
# Creates a vector of D's in the form needed for one_step_claim_discrete
# from vector in (time, dividend, time, dividend,...) form
# assuming the times are in increasing order
len <- length(vec)
output <- c()
for (i in seq(1,len,2)){
t <- vec[i]
j <- ceiling(t/h) - 1
output <- append(output,rep(0,j))
t <- t - h*(j+1)
D <- vec[i+1]
D <- D*exp(r*t)
output <- append(output, D)
}
i <- length(output)
if (i > n){
output <- output[1:n]
} else{
i <- n - i
output <- append(output, rep(0,i))
}
return(output)
}
generate_D(vec,n,h,r)
j <- ceiling(t/h)-1
j
output <- c()
output <- append(output, rep(0,j))
generate_D <- function(vec,n,h,r){
# Creates a vector of D's in the form needed for one_step_claim_discrete
# from vector in (time, dividend, time, dividend,...) form
# assuming the times are in increasing order
len <- length(vec)
output <- c()
for (i in seq(1,len,2)){
t <- vec[i]
j <- ceiling(t/h) - 1
j <- j - length(output)
output <- append(output,rep(0,j))
t <- t - h*(j+1)
D <- vec[i+1]
D <- D*exp(r*t)
output <- append(output, D)
}
i <- length(output)
if (i > n){
output <- output[1:n]
} else{
i <- n - i
output <- append(output, rep(0,i))
}
return(output)
}
generate_D(vec,n,h,r)
r <- 0.1
generate_D(vec,n,h,r)
vec
exp(0.05*0.25)
exp(0.05*0.25)*4
exp(0.05*0.1)*4
exp(0.`*0.1)*4
exp(0.`*0.1)*4
exp(0.1*0.1)*4
generate_D <- function(vec,n,h,r){
# Creates a vector of D's in the form needed for one_step_claim_discrete
# from vector in (time, dividend, time, dividend,...) form
# assuming the times are in increasing order
len <- length(vec)
output <- c()
for (i in seq(1,len,2)){
t <- vec[i]
j <- ceiling(t/h) - 1
t <- t - h*(j+1)
j <- j - length(output)
output <- append(output,rep(0,j))
D <- vec[i+1]
D <- D*exp(r*t)
output <- append(output, D)
}
i <- length(output)
if (i > n){
output <- output[1:n]
} else{
i <- n - i
output <- append(output, rep(0,i))
}
return(output)
}
generate_D(vec,n,h,r)
generate_D <- function(vec,n,h,r){
# Creates a vector of D's in the form needed for one_step_claim_discrete
# from vector in (time, dividend, time, dividend,...) form
# assuming the times are in increasing order
len <- length(vec)
output <- c()
for (i in seq(1,len,2)){
t <- vec[i]
j <- ceiling(t/h) - 1
t <- h*(j+1) - t
j <- j - length(output)
output <- append(output,rep(0,j))
D <- vec[i+1]
D <- D*exp(r*t)
output <- append(output, D)
}
i <- length(output)
if (i > n){
output <- output[1:n]
} else{
i <- n - i
output <- append(output, rep(0,i))
}
return(output)
}
generate_D(vec,n,h,r)
